# goit-algo-hw-04
# Набори даних:
Генератор генерує задану кількість унікальних елементів,
всього для замірів використав 4 набори даних з: 1 000, 10 000, 100 000, 1 000 000 елементів 

# Заміри:
| Алгоритм        |Часова складність    | 1 000               | 10 000            | 100 000         | 1 000 000        |
|-----------------|---------------------|---------------------|-------------------|-----------------|-------------------
| Timsort(sorted) | O(n log n)          | 0.0010468930000     | 0.014070553999    | 0.39002582700   | 1.6143088259     |
| Timsort(sort)   | O(n log n)          | 0.0010030549999     | 0.011508411999    | 0.15278346799   | 1.3773102830     |
| Merge           | O(n log n)          | 0.0083616059999     | 0.090778323999    | 0.99687819600   | 10.975302990     |
| Insertion       | O(n^2)              | 0.0874846069999     | 11.04756530000    | 528.187136292   | 2 hours <        |


# Висновок
Порівнюючи різні алгоритми сортування, стає очевидним, що найшвидший серед них - це `Timsort`. Також можна підтвердити, що алгоритм сортування вставками (`Insertion`) має квадратичну складність, що стає помітним на великих обсягах даних. Наприклад, на наборі з 1 000 000 елементів він вимагав більше 2 годин для завершення, і я вирішив примусово зупинити процес. Це дозволяє зробити висновок, що вбудований алгоритм сортування в `Python` є дуже ефективним порівняно з іншими.